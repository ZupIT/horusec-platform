// Copyright 2021 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package management

import (
	"fmt"

	"github.com/google/uuid"

	analysisEntities "github.com/ZupIT/horusec-devkit/pkg/entities/analysis"
	vulnerabilityEntities "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/utils/pagination"

	managementEntities "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
	managementUseCases "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/management"
)

type IRepository interface {
	GetAllVulnerabilities(filter *managementEntities.Filter) (*managementEntities.Response, error)
	GetVulnerability(vulnerabilityID uuid.UUID) (vuln *vulnerabilityEntities.Vulnerability, err error)
	GetAnalysis(analysisID uuid.UUID) (analysis *analysisEntities.Analysis, err error)
}

type Repository struct {
	databaseWrite database.IDatabaseWrite
	databaseRead  database.IDatabaseRead
	useCases      managementUseCases.IUseCases
}

func NewManagementRepository(connection *database.Connection, useCases managementUseCases.IUseCases) IRepository {
	return &Repository{
		databaseWrite: connection.Write,
		databaseRead:  connection.Read,
		useCases:      useCases,
	}
}

func (r *Repository) GetAllVulnerabilities(filter *managementEntities.Filter) (*managementEntities.Response, error) {
	totalItems, err := r.getTotalVulnerabilities(filter)
	if err != nil {
		return nil, err
	}

	responseData, err := r.getVulnerabilitiesPaginated(filter)
	if err != nil {
		return nil, err
	}

	return &managementEntities.Response{
		TotalItems: totalItems,
		Data:       responseData,
	}, nil
}

func (r *Repository) getTotalVulnerabilities(filter *managementEntities.Filter) (count int, err error) {
	condition, params := filter.GetWhereFilterQuery()

	query := fmt.Sprintf(r.getTotalVulnerabilitiesQuery(), condition)

	return count, r.databaseRead.Raw(query, &count, params...).GetErrorExceptNotFound()
}

func (r *Repository) getTotalVulnerabilitiesQuery() string {
	return `
		SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE %s AND analysis.analysis_id = (SELECT analysis_id FROM analysis ORDER BY created_at DESC LIMIT 1)
	`
}

func (r *Repository) getVulnerabilitiesPaginated(
	filter *managementEntities.Filter) (*[]managementEntities.ResponseData, error) {
	responseData := &[]managementEntities.ResponseData{}

	query, params := r.getVulnerabilitiesPaginatedQuery(filter)

	return responseData, r.databaseRead.Raw(query, responseData, params...).GetErrorExceptNotFound()
}

func (r *Repository) getVulnerabilitiesPaginatedQuery(filter *managementEntities.Filter) (string, []interface{}) {
	subQuery, params := r.getVulnerabilitiesPaginatedSubQuery(filter)

	query := fmt.Sprintf(`
		SELECT * FROM (%s) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END, tmpTable.type DESC LIMIT ? OFFSET ?
	`, subQuery)

	params = append(params, filter.Size, pagination.GetSkip(int64(filter.Page), int64(filter.Size)))
	return query, params
}

func (r *Repository) getVulnerabilitiesPaginatedSubQuery(filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	subQuery := fmt.Sprintf(`
		SELECT vulnerabilities.*, analysis.analysis_id  
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE %s AND analysis.analysis_id = (SELECT analysis_id FROM analysis ORDER BY created_at DESC LIMIT 1)
		GROUP BY vulnerabilities.vulnerability_id, analysis.analysis_id`, condition)

	return subQuery, params
}

func (r *Repository) GetVulnerability(vulnerabilityID uuid.UUID) (*vulnerabilityEntities.Vulnerability, error) {
	vulnerability := &vulnerabilityEntities.Vulnerability{}

	return vulnerability, r.databaseRead.Find(vulnerability, r.useCases.FilterVulnerabilityByID(vulnerabilityID),
		managementEnums.VulnerabilitiesTable).GetError()
}

func (r *Repository) GetAnalysis(analysisID uuid.UUID) (*analysisEntities.Analysis, error) {
	analysis := &analysisEntities.Analysis{}

	preloads := map[string][]interface{}{
		"AnalysisVulnerabilities":               {},
		"AnalysisVulnerabilities.Vulnerability": {},
	}

	return analysis, r.databaseRead.FindPreload(analysis, r.useCases.FilterAnalysisByID(analysisID),
		preloads, managementEnums.AnalysisTable).GetError()
}
