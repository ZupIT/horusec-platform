// Copyright 2021 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package management

import (
	"fmt"

	"github.com/google/uuid"

	analysisEntities "github.com/ZupIT/horusec-devkit/pkg/entities/analysis"
	vulnerabilityEntities "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"

	managementEntities "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
	managementUseCases "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/management"
)

type IRepository interface {
	ListVulnerabilitiesByFile(filter *managementEntities.Filter) (*managementEntities.ResponseVulnerabilitiesByFile, error)
	ListVulnerableFiles(filter *managementEntities.Filter) (*managementEntities.ResponseFilesVulnerable, error)
	GetVulnerability(vulnerabilityID uuid.UUID) (vuln *vulnerabilityEntities.Vulnerability, err error)
	GetAnalysis(analysisID uuid.UUID) (analysis *analysisEntities.Analysis, err error)
}

type Repository struct {
	databaseWrite database.IDatabaseWrite
	databaseRead  database.IDatabaseRead
	useCases      managementUseCases.IUseCases
}

func NewManagementRepository(connection *database.Connection, useCases managementUseCases.IUseCases) IRepository {
	return &Repository{
		databaseWrite: connection.Write,
		databaseRead:  connection.Read,
		useCases:      useCases,
	}
}

func (r *Repository) ListVulnerableFiles(
	filter *managementEntities.Filter) (*managementEntities.ResponseFilesVulnerable, error) {
	totalItems, err := r.getTotalFilesVulnerable(filter)
	if err != nil {
		return nil, err
	}

	responseData, err := r.getFilesVulnerablePaginated(filter)
	if err != nil {
		return nil, err
	}

	return &managementEntities.ResponseFilesVulnerable{
		TotalItems: totalItems,
		Data:       responseData,
	}, nil
}

func (r *Repository) ListVulnerabilitiesByFile(
	filter *managementEntities.Filter) (*managementEntities.ResponseVulnerabilitiesByFile, error) {
	totalItems, err := r.getTotalVulnerabilitiesOfTheFile(filter)
	if err != nil {
		return nil, err
	}

	responseData, err := r.getVulnerabilitiesOfTheFilePaginated(filter)
	if err != nil {
		return nil, err
	}

	return &managementEntities.ResponseVulnerabilitiesByFile{
		TotalItems: totalItems,
		Data:       responseData,
	}, nil
}

func (r *Repository) getTotalFilesVulnerable(filter *managementEntities.Filter) (count int, err error) {
	query, params := r.getTotalFilesVulnerableQuery(filter)

	return count, r.databaseRead.Raw(query, &count, params...).GetErrorExceptNotFound()
}

func (r *Repository) getTotalVulnerabilitiesOfTheFile(filter *managementEntities.Filter) (count int, err error) {
	query, params := r.getTotalVulnerabilitiesOfTheFileQuery(filter)

	return count, r.databaseRead.Raw(query, &count, params...).GetErrorExceptNotFound()
}

func (r *Repository) getTotalFilesVulnerableQuery(filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT count(*) FROM (
			SELECT '-' as file FROM analysis
			JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
			JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
			WHERE %[1]s
			GROUP BY vulnerabilities.file
		) as count
	`, condition), params
}

func (r *Repository) getTotalVulnerabilitiesOfTheFileQuery(filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) ) FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE %[1]s
	`, condition), params
}

func (r *Repository) getFilesVulnerablePaginated(
	filter *managementEntities.Filter) ([]managementEntities.ResponseDataFilesVulnerable, error) {
	responseData := []managementEntities.ResponseDataFilesVulnerable{}

	query, params := r.getFilesVulnerablePaginatedQuery(filter)

	return responseData, r.databaseRead.Raw(query, &responseData, params...).GetErrorExceptNotFound()
}

func (r *Repository) getVulnerabilitiesOfTheFilePaginated(
	filter *managementEntities.Filter) ([]vulnerabilityEntities.Vulnerability, error) {
	responseData := []vulnerabilityEntities.Vulnerability{}

	query, params := r.getVulnerabilitiesOfTheFilePaginatedQuery(filter)

	return responseData, r.databaseRead.Raw(query, &responseData, params...).GetErrorExceptNotFound()
}

// nolint:funlen // query is not necessary broken
func (r *Repository) getFilesVulnerablePaginatedQuery(
	filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT * FROM (
			SELECT COUNT(vulnerabilities.vulnerability_id) as total_vulnerabilities,
				vulnerabilities.file, analysis.created_at, analysis.analysis_id,
				repositories.repository_id, repositories.name as repository_name FROM analysis
			JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
			JOIN repositories ON analysis.repository_id = repositories.repository_id
			JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
			WHERE %[1]s
			GROUP BY vulnerabilities.file, analysis.created_at, analysis.analysis_id,
				repositories.repository_id, repositories.name
		) AS tmpTable
		ORDER BY tmpTable.total_vulnerabilities DESC, tmpTable.file
		LIMIT @size OFFSET @skip
	`, condition), params
}

func (r *Repository) getVulnerabilitiesOfTheFilePaginatedQuery(
	filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT * FROM (
			SELECT vulnerabilities.* FROM analysis
			JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
			JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
			WHERE %[1]s
		) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END
		LIMIT @size OFFSET @skip
	`, condition), params
}

func (r *Repository) GetVulnerability(vulnerabilityID uuid.UUID) (*vulnerabilityEntities.Vulnerability, error) {
	vulnerability := &vulnerabilityEntities.Vulnerability{}

	return vulnerability, r.databaseRead.Find(vulnerability, r.useCases.FilterVulnerabilityByID(vulnerabilityID),
		managementEnums.VulnerabilitiesTable).GetError()
}

func (r *Repository) GetAnalysis(analysisID uuid.UUID) (*analysisEntities.Analysis, error) {
	analysis := &analysisEntities.Analysis{}

	preloads := map[string][]interface{}{
		"AnalysisVulnerabilities":               {},
		"AnalysisVulnerabilities.Vulnerability": {},
	}

	return analysis, r.databaseRead.FindPreload(analysis, r.useCases.FilterAnalysisByID(analysisID),
		preloads, managementEnums.AnalysisTable).GetError()
}
