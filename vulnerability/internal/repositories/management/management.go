package management

import (
	"fmt"

	"github.com/google/uuid"

	analysisEntities "github.com/ZupIT/horusec-devkit/pkg/entities/analysis"
	vulnerabilityEntities "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"

	managementEntities "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
	managementUseCases "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/management"
)

type IRepository interface {
	GetAllVulnerabilities(filter *managementEntities.Filter) (*managementEntities.Response, error)
	GetVulnerability(vulnerabilityID uuid.UUID) (vuln *vulnerabilityEntities.Vulnerability, err error)
	GetAnalysis(analysisID uuid.UUID) (analysis *analysisEntities.Analysis, err error)
}

type Repository struct {
	databaseWrite database.IDatabaseWrite
	databaseRead  database.IDatabaseRead
	useCases      managementUseCases.IUseCases
}

func NewManagementRepository(connection *database.Connection, useCases managementUseCases.IUseCases) IRepository {
	return &Repository{
		databaseWrite: connection.Write,
		databaseRead:  connection.Read,
		useCases:      useCases,
	}
}

func (r *Repository) GetAllVulnerabilities(filter *managementEntities.Filter) (*managementEntities.Response, error) {
	totalItems, err := r.getTotalVulnerabilities(filter)
	if err != nil {
		return nil, err
	}

	responseData, err := r.getVulnerabilitiesPaginated(filter)
	if err != nil {
		return nil, err
	}

	return &managementEntities.Response{
		TotalItems: totalItems,
		Data:       responseData,
	}, nil
}

func (r *Repository) getTotalVulnerabilities(filter *managementEntities.Filter) (count int, err error) {
	query, params := r.getTotalVulnerabilitiesQuery(filter)

	return count, r.databaseRead.Raw(query, &count, params...).GetErrorExceptNotFound()
}

func (r *Repository) getTotalVulnerabilitiesQuery(filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE %[1]s
	`, condition), params
}

func (r *Repository) getVulnerabilitiesPaginated(
	filter *managementEntities.Filter) (*[]managementEntities.ResponseData, error) {
	responseData := &[]managementEntities.ResponseData{}

	query, params := r.getVulnerabilitiesPaginatedQuery(filter)

	return responseData, r.databaseRead.Raw(query, responseData, params...).GetErrorExceptNotFound()
}

func (r *Repository) getVulnerabilitiesPaginatedQuery(filter *managementEntities.Filter) (string, []interface{}) {
	condition, params := filter.GetWhereFilterQuery()

	return fmt.Sprintf(`
		SELECT * FROM (
			SELECT vulnerabilities.*, analysis.analysis_id  
			FROM analysis
			JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
			JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
			WHERE %[1]s
			GROUP BY vulnerabilities.vulnerability_id, analysis.analysis_id
		) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END, tmpTable.type DESC LIMIT @size OFFSET @skip
	`, condition), params
}

func (r *Repository) GetVulnerability(vulnerabilityID uuid.UUID) (*vulnerabilityEntities.Vulnerability, error) {
	vulnerability := &vulnerabilityEntities.Vulnerability{}

	return vulnerability, r.databaseRead.Find(vulnerability, r.useCases.FilterVulnerabilityByID(vulnerabilityID),
		managementEnums.VulnerabilitiesTable).GetError()
}

func (r *Repository) GetAnalysis(analysisID uuid.UUID) (*analysisEntities.Analysis, error) {
	analysis := &analysisEntities.Analysis{}

	preloads := map[string][]interface{}{
		"AnalysisVulnerabilities":               {},
		"AnalysisVulnerabilities.Vulnerability": {},
	}

	return analysis, r.databaseRead.FindPreload(analysis, r.useCases.FilterAnalysisByID(analysisID),
		preloads, managementEnums.AnalysisTable).GetError()
}
