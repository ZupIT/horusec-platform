package vulnerability

import (
	"errors"
	"testing"

	"github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/services/database/response"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	entity "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
)

func TestRepositoryVulnerability_FindAllVulnerabilitiesByFilter(t *testing.T) {
	t.Run("Should return all vulnerabilities found without error", func(t *testing.T) {
		dbReadMock := &database.Mock{}
		countResponse := 1
		dbReadMock.On("Raw").Once().Return(response.NewResponse(1, nil, &countResponse))
		listResponse := []vulnerability.Vulnerability{{}}
		dbReadMock.On("Raw").Once().Once().Return(response.NewResponse(1, nil, &listResponse))
		dbWriteMock := &database.Mock{}
		connectionMock := &database.Connection{
			Read:  dbReadMock,
			Write: dbWriteMock,
		}
		result, err := NewRepositoryVulnerability(connectionMock).FindAllVulnerabilitiesByFilter(&entity.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Unknown,
			VulnType:     enumsVulnerability.Unknown,
			VulnHash:     "",
		})
		assert.NoError(t, err)
		assert.NotEmpty(t, result)
	})
	t.Run("Should return empty vulnerabilities found without error", func(t *testing.T) {
		dbReadMock := &database.Mock{}
		countResponse := 0
		dbReadMock.On("Raw").Once().Return(response.NewResponse(0, nil, &countResponse))
		dbReadMock.On("Raw").Once().Once().Return(response.NewResponse(0, nil, nil))
		dbWriteMock := &database.Mock{}
		connectionMock := &database.Connection{
			Read:  dbReadMock,
			Write: dbWriteMock,
		}
		result, err := NewRepositoryVulnerability(connectionMock).FindAllVulnerabilitiesByFilter(&entity.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Unknown,
			VulnType:     enumsVulnerability.Unknown,
			VulnHash:     "",
		})
		assert.NoError(t, err)
		assert.Empty(t, result.Data)
		assert.Equal(t, result.TotalItems, 0)
	})
	t.Run("Should return unknown error on count all vulnerabilities", func(t *testing.T) {
		dbReadMock := &database.Mock{}
		countResponse := 1
		dbReadMock.On("Raw").Once().Return(response.NewResponse(1, nil, &countResponse))
		listResponse := []vulnerability.Vulnerability{{}}
		dbReadMock.On("Raw").Once().Once().Return(response.NewResponse(1, errors.New("unexpected error"), &listResponse))
		dbWriteMock := &database.Mock{}
		connectionMock := &database.Connection{
			Read:  dbReadMock,
			Write: dbWriteMock,
		}
		_, err := NewRepositoryVulnerability(connectionMock).FindAllVulnerabilitiesByFilter(&entity.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Unknown,
			VulnType:     enumsVulnerability.Unknown,
			VulnHash:     "",
		})
		assert.Equal(t, err, errors.New("unexpected error"))
	})
	t.Run("Should return unknown error on list all vulnerabilities", func(t *testing.T) {
		dbReadMock := &database.Mock{}
		countResponse := 1
		dbReadMock.On("Raw").Return(response.NewResponse(1, errors.New("unexpected error"), &countResponse))
		dbWriteMock := &database.Mock{}
		connectionMock := &database.Connection{
			Read:  dbReadMock,
			Write: dbWriteMock,
		}
		_, err := NewRepositoryVulnerability(connectionMock).FindAllVulnerabilitiesByFilter(&entity.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Unknown,
			VulnType:     enumsVulnerability.Unknown,
			VulnHash:     "",
		})
		assert.Equal(t, err, errors.New("unexpected error"))
	})
	t.Run("Should return all vulnerabilities found without error with hash, type, severity", func(t *testing.T) {
		dbReadMock := &database.Mock{}
		countResponse := 1
		dbReadMock.On("Raw").Once().Return(response.NewResponse(1, nil, &countResponse))
		listResponse := []vulnerability.Vulnerability{{}}
		dbReadMock.On("Raw").Once().Once().Return(response.NewResponse(1, nil, &listResponse))
		dbWriteMock := &database.Mock{}
		connectionMock := &database.Connection{
			Read:  dbReadMock,
			Write: dbWriteMock,
		}
		result, err := NewRepositoryVulnerability(connectionMock).FindAllVulnerabilitiesByFilter(&entity.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical,
			VulnType:     enumsVulnerability.Vulnerability,
			VulnHash:     "123456",
		})
		assert.NoError(t, err)
		assert.NotEmpty(t, result)
	})
}
