package vulnerability

import (
	"fmt"

	"github.com/ZupIT/horusec-devkit/pkg/entities/analysis"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/google/uuid"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/enums/usecase"

	entityVulnerability "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"

	"github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/utils/pagination"
)

type IRepositoryVulnerability interface {
	GetAllAnalysisByVulnerabilityID(vulnerabilityID uuid.UUID) ([]analysis.Analysis, error)
	FindAllVulnerabilitiesByFilter(
		filter *entityVulnerability.FilterToFindAllVulnerabilities) (*entityVulnerability.FindVulnerabilities, error)
	UpdateVulnerability(updateVulnerability *entityVulnerability.UpdateVulnerability) error
}

type RepositoryVulnerability struct {
	databaseWrite       database.IDatabaseWrite
	databaseRead        database.IDatabaseRead
	repositoryTableName string
}

func NewRepositoryVulnerability(connection *database.Connection) IRepositoryVulnerability {
	return &RepositoryVulnerability{
		databaseWrite:       connection.Write,
		databaseRead:        connection.Read,
		repositoryTableName: (&vulnerability.Vulnerability{}).GetTable(),
	}
}

func (r *RepositoryVulnerability) GetAllAnalysisByVulnerabilityID(
	vulnerabilityID uuid.UUID) ([]analysis.Analysis, error) {
	preloads := map[string][]interface{}{
		"AnalysisVulnerabilities":               {},
		"AnalysisVulnerabilities.Vulnerability": {map[string]interface{}{"vulnerability_id": vulnerabilityID}},
	}
	res := r.databaseRead.FindPreload(&[]analysis.Analysis{},
		map[string]interface{}{}, preloads, (&analysis.Analysis{}).GetTable())
	if res.GetError() != nil {
		return nil, res.GetError()
	}
	if res.GetData() == nil {
		return []analysis.Analysis{}, nil
	}
	return *res.GetData().(*[]analysis.Analysis), nil
}

func (r *RepositoryVulnerability) UpdateVulnerability(
	updateVulnerability *entityVulnerability.UpdateVulnerability) error {
	condition := map[string]interface{}{"vulnerability_id": updateVulnerability.VulnerabilityID}
	entityToUpdate := map[string]interface{}{
		"severity": updateVulnerability.Severity,
		"type":     updateVulnerability.Type,
	}
	res := r.databaseWrite.Update(entityToUpdate, condition, (&vulnerability.Vulnerability{}).GetTable())
	return res.GetError()
}

func (r *RepositoryVulnerability) FindAllVulnerabilitiesByFilter(
	filter *entityVulnerability.FilterToFindAllVulnerabilities) (*entityVulnerability.FindVulnerabilities, error) {
	totalItems, err := r.getTotalVulnerabilitiesByFilter(filter)
	if err != nil {
		return &entityVulnerability.FindVulnerabilities{}, err
	}
	listVulnerability, err := r.getPaginatedVulnerabilitiesByFilter(filter)
	if err != nil {
		return &entityVulnerability.FindVulnerabilities{}, err
	}
	return &entityVulnerability.FindVulnerabilities{
		TotalItems: totalItems,
		Data:       listVulnerability,
	}, nil
}

func (r *RepositoryVulnerability) getTotalVulnerabilitiesByFilter(
	filter *entityVulnerability.FilterToFindAllVulnerabilities) (count int, err error) {
	condition, params := r.setWhereFilter(filter)
	result := r.databaseRead.Raw(`SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE `+condition, &count, params...)
	return count, result.GetError()
}

func (r *RepositoryVulnerability) setWhereFilter(
	filter *entityVulnerability.FilterToFindAllVulnerabilities) (string, []interface{}) {
	query := "analysis.workspace_id = ?"
	params := []interface{}{filter.WorkspaceID}
	query, params = r.addVulnRepositoryIDToWhereFilter(filter.RepositoryID, query, params)
	query, params = r.addVulnHashToWhereFilter(filter.VulnHash, query, params)
	query, params = r.addVulnSeverityToWhereFilter(filter.VulnSeverity, query, params)
	query, params = r.addVulnTypeToWhereFilter(filter.VulnType, query, params)
	return query, params
}

func (r *RepositoryVulnerability) addVulnRepositoryIDToWhereFilter(repositoryID uuid.UUID,
	query string, params []interface{}) (string, []interface{}) {
	if repositoryID != uuid.Nil {
		query += " AND analysis.repository_id = ? "
		params = append(params, repositoryID)
	}
	return query, params
}

func (r *RepositoryVulnerability) addVulnHashToWhereFilter(
	hash string, query string, params []interface{}) (string, []interface{}) {
	if hash != "" {
		query += " AND vulnerabilities.vuln_hash ILIKE ? "
		params = append(params, "%"+hash+"%")
	}
	return query, params
}

func (r *RepositoryVulnerability) addVulnSeverityToWhereFilter(
	severity string, query string, params []interface{}) (string, []interface{}) {
	severityParsed := severities.Severity(severity)
	if severity != usecase.AllFilter && severityParsed.IsValid() {
		query += " AND vulnerabilities.severity = ? "
		params = append(params, severity)
	}
	return query, params
}

func (r *RepositoryVulnerability) addVulnTypeToWhereFilter(
	vulnType string, query string, params []interface{}) (string, []interface{}) {
	vulnTypeParsed := enumsVulnerability.Type(vulnType)
	if vulnType != usecase.AllFilter && vulnTypeParsed.IsValid() {
		query += " AND vulnerabilities.type = ? "
		params = append(params, vulnType)
	}
	return query, params
}

func (r *RepositoryVulnerability) getPaginatedVulnerabilitiesByFilter(
	filter *entityVulnerability.FilterToFindAllVulnerabilities) ([]vulnerability.Vulnerability, error) {
	subQuery, params := r.getSubQueryAndParamsToCondition(filter)
	params = append(params, filter.Size, pagination.GetSkip(int64(filter.Page), int64(filter.Size)))
	result := r.databaseRead.Raw(`SELECT * FROM (`+subQuery+`) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END, tmpTable.type DESC LIMIT ? OFFSET ?`,
		&[]vulnerability.Vulnerability{}, params...)
	if result.GetError() != nil {
		return nil, result.GetError()
	}
	if result.GetData() != nil {
		return *result.GetData().(*[]vulnerability.Vulnerability), nil
	}
	return []vulnerability.Vulnerability{}, nil
}

func (r *RepositoryVulnerability) getSubQueryAndParamsToCondition(
	filter *entityVulnerability.FilterToFindAllVulnerabilities) (string, []interface{}) {
	condition, paramsCondition := r.setWhereFilter(filter)
	subQuery := fmt.Sprintf(`SELECT vulnerabilities.* 
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE %s GROUP BY vulnerabilities.vulnerability_id`, condition)
	return subQuery, paramsCondition
}
