package vulnerability

import (
	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"

	entity "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"

	"github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/utils/pagination"
)

type IRepositoryVulnerability interface {
	FindAllVulnerabilitiesByFilter(
		filter *entity.FilterToFindAllVulnerabilities) (*entity.FindVulnerabilities, error)
	UpdateVulnerability(updateVulnerability *entity.UpdateVulnerability) error
}

type RepositoryVulnerability struct {
	databaseWrite       database.IDatabaseWrite
	databaseRead        database.IDatabaseRead
	repositoryTableName string
}

func NewRepositoryVulnerability(connection *database.Connection) IRepositoryVulnerability {
	return &RepositoryVulnerability{
		databaseWrite:       connection.Write,
		databaseRead:        connection.Read,
		repositoryTableName: (&vulnerability.Vulnerability{}).GetTable(),
	}
}

func (r *RepositoryVulnerability) UpdateVulnerability(updateVulnerability *entity.UpdateVulnerability) error {
	condition := map[string]interface{}{"vulnerability_id": updateVulnerability.VulnerabilityID}
	entityToUpdate := map[string]interface{}{
		"severity": updateVulnerability.Severity,
		"type":     updateVulnerability.Type,
	}
	res := r.databaseWrite.Update(entityToUpdate, condition, (&vulnerability.Vulnerability{}).GetTable())
	return res.GetError()
}

func (r *RepositoryVulnerability) FindAllVulnerabilitiesByFilter(
	filter *entity.FilterToFindAllVulnerabilities) (*entity.FindVulnerabilities, error) {
	totalItems, err := r.getTotalVulnerabilitiesByFilter(filter)
	if err != nil {
		return &entity.FindVulnerabilities{}, err
	}
	listVulnerability, err := r.getPaginatedVulnerabilitiesByFilter(filter)
	if err != nil {
		return &entity.FindVulnerabilities{}, err
	}
	return &entity.FindVulnerabilities{
		TotalItems: totalItems,
		Data:       listVulnerability,
	}, nil
}

func (r *RepositoryVulnerability) getTotalVulnerabilitiesByFilter(
	filter *entity.FilterToFindAllVulnerabilities) (count int, err error) {
	condition, params := r.setWhereFilter(filter)
	result := r.databaseRead.Raw(`SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE `+condition, &count, params...)
	return count, result.GetError()
}

func (r *RepositoryVulnerability) setWhereFilter(
	filter *entity.FilterToFindAllVulnerabilities) (string, []interface{}) {
	query := "analysis.repository_id = ?"
	params := []interface{}{filter.RepositoryID}
	query, params = r.addVulnHashToWhereFilter(filter.VulnHash, query, params)
	query, params = r.addVulnSeverityToWhereFilter(filter.VulnSeverity, query, params)
	query, params = r.addVulnTypeToWhereFilter(filter.VulnType, query, params)
	return query, params
}

func (r *RepositoryVulnerability) addVulnHashToWhereFilter(
	hash string, query string, params []interface{}) (string, []interface{}) {
	if hash != "" {
		query += " AND vulnerabilities.vuln_hash ~ ? "
		params = append(params, hash)
	}
	return query, params
}

func (r *RepositoryVulnerability) addVulnSeverityToWhereFilter(
	severity severities.Severity, query string, params []interface{}) (string, []interface{}) {
	if severity.IsValid() {
		query += " AND vulnerabilities.severity = ? "
		params = append(params, severity)
	}
	return query, params
}

func (r *RepositoryVulnerability) addVulnTypeToWhereFilter(
	vulnType enumsVulnerability.Type, query string, params []interface{}) (string, []interface{}) {
	if vulnType.IsValid() {
		query += " AND vulnerabilities.type = ? "
		params = append(params, vulnType)
	}
	return query, params
}

func (r *RepositoryVulnerability) getPaginatedVulnerabilitiesByFilter(
	filter *entity.FilterToFindAllVulnerabilities) ([]vulnerability.Vulnerability, error) {
	subQuery, params := r.getSubQueryAndParamsToCondition(filter)
	params = append(params, filter.Size, pagination.GetSkip(int64(filter.Page), int64(filter.Size)))
	result := r.databaseRead.Raw(`SELECT * FROM (`+subQuery+`) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END, tmpTable.type DESC LIMIT ? OFFSET ?`,
		&[]vulnerability.Vulnerability{}, params...)
	if result.GetError() != nil {
		return nil, result.GetError()
	}
	if result.GetData() != nil {
		return *result.GetData().(*[]vulnerability.Vulnerability), nil
	}
	return []vulnerability.Vulnerability{}, nil
}

func (r *RepositoryVulnerability) getSubQueryAndParamsToCondition(
	filter *entity.FilterToFindAllVulnerabilities) (string, []interface{}) {
	condition, paramsCondition := r.setWhereFilter(filter)
	subQuery := `SELECT vulnerabilities.* 
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE ` + condition
	return subQuery, paramsCondition
}
