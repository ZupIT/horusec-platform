package vulnerability

import (
	vulnerability2 "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"

	"github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/utils/pagination"
)

type IRepositoryVulnerability interface {
	FindAllVulnerabilitiesByFilter(
		filter *vulnerability2.FilterToFindAllVulnerabilities) (*vulnerability2.FindVulnerabilities, error)
}

type RepositoryVulnerability struct {
	databaseWrite       database.IDatabaseWrite
	databaseRead        database.IDatabaseRead
	repositoryTableName string
}

func NewRepositoryVulnerability(connection *database.Connection) IRepositoryVulnerability {
	return &RepositoryVulnerability{
		databaseWrite:       connection.Write,
		databaseRead:        connection.Read,
		repositoryTableName: (&vulnerability.Vulnerability{}).GetTable(),
	}
}

func (r *RepositoryVulnerability) FindAllVulnerabilitiesByFilter(
	filter *vulnerability2.FilterToFindAllVulnerabilities) (*vulnerability2.FindVulnerabilities, error) {
	totalItems, err := r.getTotalVulnerabilitiesByFilter(filter)
	if err != nil {
		return &vulnerability2.FindVulnerabilities{}, err
	}
	listVulnerability, err := r.getPaginatedVulnerabilitiesByFilter(filter)
	if err != nil {
		return &vulnerability2.FindVulnerabilities{}, err
	}
	return &vulnerability2.FindVulnerabilities{
		TotalItems: totalItems,
		Data:       listVulnerability,
	}, nil
}

func (r *RepositoryVulnerability) getTotalVulnerabilitiesByFilter(
	filter *vulnerability2.FilterToFindAllVulnerabilities) (count int, err error) {
	condition, params := r.setWhereFilter(filter)
	result := r.databaseRead.Raw(`SELECT COUNT( DISTINCT ( vulnerabilities.vulnerability_id ) )
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE `+condition, &count, params...)
	return count, result.GetError()
}

// nolint:funlen,gocyclo // method is necessary to create all factories of conditions
func (r *RepositoryVulnerability) setWhereFilter(
	filter *vulnerability2.FilterToFindAllVulnerabilities) (string, []interface{}) {
	switch {
	case filter.VulnHash != "" && filter.VulnSeverity.IsValid() && filter.VulnType.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.severity = ? AND vulnerabilities.type = ? 
					AND vulnerabilities.vuln_hash ~ ?`
		params := []interface{}{filter.RepositoryID, filter.VulnSeverity, filter.VulnType, filter.VulnHash}
		return query, params
	case filter.VulnHash != "" && filter.VulnSeverity.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.severity = ? AND vulnerabilities.vuln_hash ~ ?`
		params := []interface{}{filter.RepositoryID, filter.VulnSeverity, filter.VulnHash}
		return query, params
	case filter.VulnHash != "" && filter.VulnType.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.type = ? AND vulnerabilities.vuln_hash ~ ?`
		params := []interface{}{filter.RepositoryID, filter.VulnType, filter.VulnHash}
		return query, params
	case filter.VulnSeverity.IsValid() && filter.VulnType.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.type = ? AND vulnerabilities.severity = ?`
		params := []interface{}{filter.RepositoryID, filter.VulnType, filter.VulnSeverity}
		return query, params
	case filter.VulnHash != "":
		query := `analysis.repository_id = ? AND vulnerabilities.vuln_hash ~ ?`
		params := []interface{}{filter.RepositoryID, filter.VulnHash}
		return query, params
	case filter.VulnSeverity.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.severity = ?`
		params := []interface{}{filter.RepositoryID, filter.VulnSeverity}
		return query, params
	case filter.VulnType.IsValid():
		query := `analysis.repository_id = ? AND vulnerabilities.type = ?`
		params := []interface{}{filter.RepositoryID, filter.VulnType}
		return query, params
	default:
		return "analysis.repository_id = ?", []interface{}{filter.RepositoryID}
	}
}

func (r *RepositoryVulnerability) getPaginatedVulnerabilitiesByFilter(
	filter *vulnerability2.FilterToFindAllVulnerabilities) (entity []vulnerability.Vulnerability, err error) {
	subQuery, params := r.getSubQueryAndParamsToCondition(filter)
	params = append(params, filter.Size, pagination.GetSkip(int64(filter.Page), int64(filter.Size)))
	result := r.databaseRead.Raw(`SELECT * FROM (`+subQuery+`) AS tmpTable
		ORDER BY CASE tmpTable.severity
		WHEN 'CRITICAL' THEN 1 WHEN 'HIGH' THEN 2 WHEN 'MEDIUM' THEN 3 WHEN 'LOW' THEN 4
		WHEN 'UNKNOWN' THEN 5 WHEN 'INFO' THEN 6 END, tmpTable.type DESC LIMIT ? OFFSET ?`, &entity, params...)
	if result.GetError() != nil {
		return nil, result.GetError()
	}
	if result.GetData() != nil {
		return *result.GetData().(*[]vulnerability.Vulnerability), nil
	}
	return nil, nil
}

func (r *RepositoryVulnerability) getSubQueryAndParamsToCondition(
	filter *vulnerability2.FilterToFindAllVulnerabilities) (string, []interface{}) {
	condition, paramsCondition := r.setWhereFilter(filter)
	subQuery := `SELECT vulnerabilities.* 
		FROM analysis
		JOIN analysis_vulnerabilities ON analysis.analysis_id = analysis_vulnerabilities.analysis_id
		JOIN vulnerabilities ON vulnerabilities.vulnerability_id = analysis_vulnerabilities.vulnerability_id
		WHERE ` + condition
	return subQuery, paramsCondition
}
