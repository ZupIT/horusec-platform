package vulnerabilityfilter

import (
	netHTTP "net/http"
	"strconv"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/enums/usecase"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/go-chi/chi"
	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/google/uuid"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
	enums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums"
)

type IUseCaseVulnerabilityFilter interface {
	ParseQueryInFilterToFindAllVulnerabilities(r *netHTTP.Request) (*vulnerability.FilterToFindAllVulnerabilities, error)
}

type UseCaseVulnerabilityFilter struct{}

func NewUseCaseVulnerabilityFilter() IUseCaseVulnerabilityFilter {
	return &UseCaseVulnerabilityFilter{}
}

func (u *UseCaseVulnerabilityFilter) ParseQueryInFilterToFindAllVulnerabilities(
	r *netHTTP.Request) (filter *vulnerability.FilterToFindAllVulnerabilities, err error) {
	repositoryID, workspaceID, err := u.getRepositoryIDAndWorkspaceIDFromRequest(r)
	if err != nil {
		return nil, err
	}
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	size, _ := strconv.Atoi(r.URL.Query().Get("size"))
	entity := u.buildFilterToFindAllVulnerabilities(repositoryID, workspaceID, page, size, r)
	return entity, u.validateFilterToFindAllVulnerabilities(entity)
}

func (u *UseCaseVulnerabilityFilter) buildFilterToFindAllVulnerabilities(repositoryID, workspaceID uuid.UUID,
	page, size int, r *netHTTP.Request) *vulnerability.FilterToFindAllVulnerabilities {
	return &vulnerability.FilterToFindAllVulnerabilities{
		WorkspaceID:  workspaceID,
		RepositoryID: repositoryID,
		Page:         page,
		Size:         u.getSizeOrMin(size),
		VulnSeverity: r.URL.Query().Get("vulnSeverity"),
		VulnType:     r.URL.Query().Get("vulnType"),
		VulnHash:     r.URL.Query().Get("vulnHash"),
	}
}

func (u *UseCaseVulnerabilityFilter) getSizeOrMin(size int) int {
	if size < usecase.DefaultSize {
		return usecase.DefaultSize
	}
	return size
}

func (u *UseCaseVulnerabilityFilter) validateFilterToFindAllVulnerabilities(
	entity *vulnerability.FilterToFindAllVulnerabilities) error {
	return validation.ValidateStruct(entity,
		validation.Field(&entity.WorkspaceID, validation.Required, validation.NotIn(uuid.Nil)),
		validation.Field(&entity.RepositoryID, validation.Required),
		validation.Field(&entity.Page, validation.Min(0)),
		validation.Field(&entity.Size, validation.Min(usecase.DefaultSize)),
		validation.Field(&entity.VulnSeverity, validation.In(severities.Unknown.ToString(), severities.Critical.ToString(),
			severities.High.ToString(), severities.Medium.ToString(), severities.Low.ToString(), severities.Info.ToString(),
			usecase.AllFilter)),
		validation.Field(&entity.VulnType, validation.In(usecase.AllFilter, enumsVulnerability.Vulnerability.ToString(),
			enumsVulnerability.RiskAccepted.ToString(), enumsVulnerability.FalsePositive.ToString(),
			enumsVulnerability.Corrected.ToString())),
	)
}

func (u *UseCaseVulnerabilityFilter) getRepositoryIDAndWorkspaceIDFromRequest(
	r *netHTTP.Request) (repositoryID, workspaceID uuid.UUID, err error) {
	if chi.URLParam(r, "repositoryID") != "" {
		repositoryID, err = uuid.Parse(chi.URLParam(r, "repositoryID"))
		if err != nil {
			return uuid.Nil, uuid.Nil, enums.ErrorWrongRepositoryID
		}
	}
	workspaceID, err = uuid.Parse(chi.URLParam(r, "workspaceID"))
	if err != nil {
		return uuid.Nil, uuid.Nil, enums.ErrorWrongWorkspaceID
	}
	return repositoryID, workspaceID, nil
}
