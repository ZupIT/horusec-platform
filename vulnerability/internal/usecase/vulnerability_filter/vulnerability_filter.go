package vulnerabilityfilter

import (
	netHTTP "net/http"
	"strconv"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/go-chi/chi"
	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/google/uuid"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
	enums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums"
)

const DefaultSize = 10

type IUseCaseVulnerabilityFilter interface {
	ParseQueryInFilterToFindAllVulnerabilities(r *netHTTP.Request) (*vulnerability.FilterToFindAllVulnerabilities, error)
}

type UseCaseVulnerabilityFilter struct{}

func NewUseCaseVulnerabilityFilter() IUseCaseVulnerabilityFilter {
	return &UseCaseVulnerabilityFilter{}
}

func (u *UseCaseVulnerabilityFilter) ParseQueryInFilterToFindAllVulnerabilities(
	r *netHTTP.Request) (filter *vulnerability.FilterToFindAllVulnerabilities, err error) {
	repositoryID, workspaceID, err := u.getRepositoryIDAndWorkspaceIDFromRequest(r)
	if err != nil {
		return nil, err
	}
	page, _ := strconv.Atoi(r.URL.Query().Get("page"))
	size, _ := strconv.Atoi(r.URL.Query().Get("size"))
	entity := u.buildFilterToFindAllVulnerabilities(repositoryID, workspaceID, page, size, r)
	return entity, u.validateFilterToFindAllVulnerabilities(entity)
}

func (u *UseCaseVulnerabilityFilter) buildFilterToFindAllVulnerabilities(repositoryID, workspaceID uuid.UUID,
	page, size int, r *netHTTP.Request) *vulnerability.FilterToFindAllVulnerabilities {
	return &vulnerability.FilterToFindAllVulnerabilities{
		WorkspaceID:  workspaceID,
		RepositoryID: repositoryID,
		Page:         page,
		Size:         u.getSizeOrMin(size),
		VulnSeverity: severities.GetSeverityByString(r.URL.Query().Get("vulnSeverity")),
		VulnType:     enumsVulnerability.GetVulnTypeOrDefault(r.URL.Query().Get("vulnType")),
		VulnHash:     r.URL.Query().Get("vulnHash"),
	}
}

func (u *UseCaseVulnerabilityFilter) getSizeOrMin(size int) int {
	if size < DefaultSize {
		return DefaultSize
	}
	return size
}

func (u *UseCaseVulnerabilityFilter) validateFilterToFindAllVulnerabilities(
	entity *vulnerability.FilterToFindAllVulnerabilities) error {
	return validation.ValidateStruct(entity,
		validation.Field(&entity.WorkspaceID, validation.Required, validation.NotIn(uuid.Nil)),
		validation.Field(&entity.RepositoryID, validation.Required),
		validation.Field(&entity.Page, validation.Min(0)),
		validation.Field(&entity.Size, validation.Min(DefaultSize)),
		validation.Field(&entity.VulnSeverity, validation.In(severities.Unknown, severities.Critical,
			severities.High, severities.Medium, severities.Low, severities.Info)),
		validation.Field(&entity.VulnType, validation.In(enumsVulnerability.Vulnerability,
			enumsVulnerability.RiskAccepted, enumsVulnerability.FalsePositive, enumsVulnerability.Corrected)),
	)
}

func (u *UseCaseVulnerabilityFilter) getRepositoryIDAndWorkspaceIDFromRequest(
	r *netHTTP.Request) (repositoryID, workspaceID uuid.UUID, err error) {
	if chi.URLParam(r, "repositoryID") != "" {
		repositoryID, err = uuid.Parse(chi.URLParam(r, "repositoryID"))
		if err != nil {
			return uuid.Nil, uuid.Nil, enums.ErrorWrongRepositoryID
		}
	}
	workspaceID, err = uuid.Parse(chi.URLParam(r, "workspaceID"))
	if err != nil {
		return uuid.Nil, uuid.Nil, enums.ErrorWrongWorkspaceID
	}
	return repositoryID, workspaceID, nil
}
