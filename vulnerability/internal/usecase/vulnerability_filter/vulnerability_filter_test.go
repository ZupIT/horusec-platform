package vulnerabilityfilter

import (
	"context"
	"fmt"
	"net/http"
	"testing"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/enums"
)

func TestNewUseCaseVulnerabilityFilter(t *testing.T) {
	t.Run("Should parse query filters to entity without error", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter, err := NewUseCaseVulnerabilityFilter().ParseQueryInFilterToFindAllVulnerabilities(r)
		assert.NoError(t, err)
		assert.Equal(t, filter.WorkspaceID, workspaceID)
		assert.Equal(t, filter.RepositoryID, repositoryID)
		assert.Equal(t, filter.Size, 10)
		assert.Equal(t, filter.Page, 0)
		assert.Equal(t, filter.VulnSeverity, severities.Unknown)
		assert.Equal(t, filter.VulnType, enumsVulnerability.Vulnerability)
		assert.Equal(t, filter.VulnHash, "")
	})
	t.Run("Should parse query with parameters filters to entity without error", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()
		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), enumsVulnerability.Vulnerability.ToString(), "123456")
		r, _ := http.NewRequest(http.MethodGet, URL, nil)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter, err := NewUseCaseVulnerabilityFilter().ParseQueryInFilterToFindAllVulnerabilities(r)
		assert.NoError(t, err)
		assert.Equal(t, filter.RepositoryID, repositoryID)
		assert.Equal(t, filter.Size, 15)
		assert.Equal(t, filter.Page, 1)
		assert.Equal(t, filter.VulnSeverity, severities.Critical)
		assert.Equal(t, filter.VulnType, enumsVulnerability.Vulnerability)
		assert.Equal(t, filter.VulnHash, "123456")
	})
	t.Run("Should return error when send not valid workspaceID", func(t *testing.T) {
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", "test")
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter, err := NewUseCaseVulnerabilityFilter().ParseQueryInFilterToFindAllVulnerabilities(r)
		assert.Equal(t, err, enums.ErrorWrongWorkspaceID)
		assert.Nil(t, filter)
	})
	t.Run("Should return error when send not valid repositoryID", func(t *testing.T) {
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		ctx := chi.NewRouteContext()
		workspaceID := uuid.New()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", "test")
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter, err := NewUseCaseVulnerabilityFilter().ParseQueryInFilterToFindAllVulnerabilities(r)
		assert.Equal(t, err, enums.ErrorWrongRepositoryID)
		assert.Nil(t, filter)
	})
	t.Run("Should return error when send not valid repositoryID", func(t *testing.T) {
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		ctx := chi.NewRouteContext()
		workspaceID := uuid.New()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", "test")
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter, err := NewUseCaseVulnerabilityFilter().ParseQueryInFilterToFindAllVulnerabilities(r)
		assert.Equal(t, err, enums.ErrorWrongRepositoryID)
		assert.Nil(t, filter)
	})
}
