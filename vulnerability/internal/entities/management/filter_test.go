// Copyright 2021 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package management

import (
	"context"
	"fmt"
	"net/http"
	"testing"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	vulnerabilityEnums "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"

	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
)

func TestSetFilterDataFromRequest(t *testing.T) {
	t.Run("should parse query with parameters filters to entity without errors", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s&vulnFile=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456", "go.mod")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r, true))
		assert.Equal(t, repositoryID, filter.RepositoryID)
		assert.Equal(t, 15, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should parse query with parameters filters to entity without errors", func(t *testing.T) {
		workspaceID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s&vulnFile=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456", "go.mod")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r, true))
		assert.Equal(t, 15, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should return error when not valid workspaceID", func(t *testing.T) {
		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s&vulnFile=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456", "go.mod")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", "test")
		ctx.URLParams.Add("repositoryID", uuid.NewString())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		err := filter.SetFilterDataFromRequest(r, true)
		assert.Error(t, err)
		assert.Equal(t, err, managementEnums.ErrorInvalidWorkspaceID)
	})

	t.Run("should return error when not valid repositoryID", func(t *testing.T) {
		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s&vulnFile=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456", "go.mod")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", uuid.New().String())
		ctx.URLParams.Add("repositoryID", "test")

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		err := filter.SetFilterDataFromRequest(r, true)
		assert.Error(t, err)
		assert.Equal(t, managementEnums.ErrorInvalidRepositoryID, err)
	})

	t.Run("should success parse the request data to filter with min pagination size", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=1&vulnSeverity=%s&vulnType=%s&vulnHash=%s&vulnFile=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456", "go.mod")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r, true))
		assert.Equal(t, repositoryID, filter.RepositoryID)
		assert.Equal(t, 10, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should return error when invalid pagination size", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := "/test?page=1"
		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.Error(t, filter.SetFilterDataFromRequest(r, true))
	})

	t.Run("should return error when invalid pagination page", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		r, _ := http.NewRequest(http.MethodGet, "", nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.Error(t, filter.SetFilterDataFromRequest(r, true))
	})

	t.Run("should return error when user not sent vulnerability file and is required", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		err := filter.SetFilterDataFromRequest(r, true)
		assert.Error(t, err)
		assert.Equal(t, managementEnums.MessageInvalidVulnFile, err.Error())
	})
}

func TestValidate(t *testing.T) {
	t.Run("should return no error when valid filter", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     vulnerabilityEnums.Vulnerability.ToString(),
			VulnHash:     "123456",
		}

		assert.NoError(t, filter.Validate())
	})

	t.Run("should return error when user not sent vulnerability type", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnHash:     "123456",
		}
		err := filter.Validate()
		assert.Error(t, err)
		assert.Equal(t, "vulnType: cannot be blank.", err.Error())
	})
}

func TestGetWhereFilterQuery(t *testing.T) {
	t.Run("should return no error when valid filter without hash", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     vulnerabilityEnums.Vulnerability.ToString(),
			VulnFile:     "go.mod",
		}

		query, params := filter.GetWhereFilterQuery()
		assert.NotEmpty(t, query)
		assert.Equal(t, "analysis.workspace_id = @workspaceID "+
			"AND analysis.repository_id = @repositoryID  "+
			"AND vulnerabilities.severity = @vulnSeverity  "+
			"AND vulnerabilities.type = @vulnType  "+
			"AND vulnerabilities.file = @vulnFile  "+
			"AND analysis.analysis_id = ("+
			"SELECT analysis_id FROM analysis "+
			"WHERE analysis.workspace_id = @workspaceID "+
			"AND analysis.repository_id = @repositoryID  "+
			"ORDER BY created_at DESC LIMIT 1)", query)
		assert.NotNil(t, params)
		assert.Len(t, params, 8)
	})
	t.Run("should return no error when valid filter with hash", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnHash:     "123456",
			VulnFile:     "go.mod",
		}

		query, params := filter.GetWhereFilterQuery()
		assert.NotEmpty(t, query)
		assert.Equal(t, "analysis.workspace_id = @workspaceID "+
			"AND analysis.repository_id = @repositoryID  "+
			"AND vulnerabilities.vuln_hash ILIKE @vulnHash  "+
			"AND vulnerabilities.severity = @vulnSeverity  "+
			"AND vulnerabilities.file = @vulnFile  "+
			"AND analysis.analysis_id = ("+
			"SELECT analysis_id FROM analysis "+
			"WHERE analysis.workspace_id = @workspaceID "+
			"AND analysis.repository_id = @repositoryID  "+
			"ORDER BY created_at DESC LIMIT 1)", query)
		assert.NotNil(t, params)
		assert.Len(t, params, 8)
	})
}

func TestGetLatestAnalysisIDByFilter(t *testing.T) {
	t.Run("should return query by workspace", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID: uuid.New(),
		}

		query := filter.getLatestAnalysisIDByFilter("")
		assert.NotEmpty(t, query)
		assert.Equal(t, " AND analysis.analysis_id IN (SELECT DISTINCT ON(analysis.repository_id)"+
			" analysis.analysis_id FROM analysis WHERE analysis.workspace_id = @workspaceID  "+
			"ORDER BY analysis.repository_id, analysis.created_at DESC)", query)
	})

	t.Run("should return query by workspace and repository", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
		}

		query := filter.getLatestAnalysisIDByFilter("")
		assert.NotEmpty(t, query)
		assert.Equal(t, " AND analysis.analysis_id = (SELECT analysis_id FROM analysis WHERE "+
			"analysis.workspace_id = @workspaceID AND analysis.repository_id = @repositoryID  "+
			"ORDER BY created_at DESC LIMIT 1)", query)
	})
}
