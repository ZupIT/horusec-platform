package management

import (
	"context"
	"fmt"
	"net/http"
	"testing"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	vulnerabilityEnums "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"

	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
)

func TestSetFilterDataFromRequest(t *testing.T) {
	t.Run("should parse query with parameters filters to entity without errors", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r))
		assert.Equal(t, repositoryID, filter.RepositoryID)
		assert.Equal(t, 15, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should parse query with parameters filters to entity without errors", func(t *testing.T) {
		workspaceID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r))
		assert.Equal(t, 15, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should return error when not valid workspaceID", func(t *testing.T) {
		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", "test")
		ctx.URLParams.Add("repositoryID", uuid.NewString())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		err := filter.SetFilterDataFromRequest(r)
		assert.Error(t, err)
		assert.Equal(t, err, managementEnums.ErrorInvalidWorkspaceID)
	})

	t.Run("should return error when not valid repositoryID", func(t *testing.T) {
		URL := fmt.Sprintf("/test?page=1&size=15&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", uuid.New().String())
		ctx.URLParams.Add("repositoryID", "test")

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		err := filter.SetFilterDataFromRequest(r)
		assert.Error(t, err)
		assert.Equal(t, managementEnums.ErrorInvalidRepositoryID, err)
	})

	t.Run("should success parse the request data to filter with min pagination size", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := fmt.Sprintf("/test?page=1&size=1&vulnSeverity=%s&vulnType=%s&vulnHash=%s",
			severities.Critical.ToString(), vulnerabilityEnums.Vulnerability.ToString(), "123456")

		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.NoError(t, filter.SetFilterDataFromRequest(r))
		assert.Equal(t, repositoryID, filter.RepositoryID)
		assert.Equal(t, 10, filter.Size)
		assert.Equal(t, 1, filter.Page)
		assert.Equal(t, severities.Critical.ToString(), filter.VulnSeverity)
		assert.Equal(t, vulnerabilityEnums.Vulnerability.ToString(), filter.VulnType)
		assert.Equal(t, "123456", filter.VulnHash)
	})

	t.Run("should return error when invalid pagination size", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		URL := "/test?page=1"
		r, _ := http.NewRequest(http.MethodGet, URL, nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.Error(t, filter.SetFilterDataFromRequest(r))
	})

	t.Run("should return error when invalid pagination page", func(t *testing.T) {
		workspaceID := uuid.New()
		repositoryID := uuid.New()

		r, _ := http.NewRequest(http.MethodGet, "", nil)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", workspaceID.String())
		ctx.URLParams.Add("repositoryID", repositoryID.String())

		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		filter := &Filter{}
		assert.Error(t, filter.SetFilterDataFromRequest(r))
	})
}

func TestValidate(t *testing.T) {
	t.Run("should return no error when valid filter", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     vulnerabilityEnums.Vulnerability.ToString(),
			VulnHash:     "123456",
		}

		assert.NoError(t, filter.Validate())
	})
}

func TestGetWhereFilterQuery(t *testing.T) {
	t.Run("should return no error when valid filter", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
			Page:         1,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     vulnerabilityEnums.Vulnerability.ToString(),
			VulnHash:     "123456",
		}

		query, params := filter.GetWhereFilterQuery()
		assert.NotEmpty(t, query)
		assert.Equal(t, "analysis.workspace_id = @workspaceID AND analysis.repository_id = @repositoryID  "+
			"AND vulnerabilities.vuln_hash ILIKE @vulnHash  AND vulnerabilities.severity = @vulnSeverity  "+
			"AND vulnerabilities.type = @vulnType  AND analysis.analysis_id = "+
			"(SELECT analysis_id FROM analysis WHERE analysis.workspace_id = @workspaceID"+
			" AND analysis.repository_id = @repositoryID  ORDER BY created_at DESC LIMIT 1)", query)
		assert.NotNil(t, params)
		assert.Len(t, params, 7)
	})
}

func TestGetLatestAnalysisIDByFilter(t *testing.T) {
	t.Run("should return query by workspace", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID: uuid.New(),
		}

		query := filter.getLatestAnalysisIDByFilter("")
		assert.NotEmpty(t, query)
		assert.Equal(t, " AND analysis.analysis_id IN (SELECT DISTINCT ON(analysis.repository_id)"+
			" analysis.analysis_id FROM analysis WHERE analysis.workspace_id = @workspaceID  "+
			"ORDER BY analysis.repository_id, analysis.created_at DESC)", query)
	})

	t.Run("should return query by workspace and repository", func(t *testing.T) {
		filter := &Filter{
			WorkspaceID:  uuid.New(),
			RepositoryID: uuid.New(),
		}

		query := filter.getLatestAnalysisIDByFilter("")
		assert.NotEmpty(t, query)
		assert.Equal(t, " AND analysis.analysis_id = (SELECT analysis_id FROM analysis WHERE "+
			"analysis.workspace_id = @workspaceID AND analysis.repository_id = @repositoryID  "+
			"ORDER BY created_at DESC LIMIT 1)", query)
	})
}
