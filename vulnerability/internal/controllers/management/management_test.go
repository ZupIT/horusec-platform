package management

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"

	analysisEntities "github.com/ZupIT/horusec-devkit/pkg/entities/analysis"
	vulnerabilityEntities "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/broker"

	managementEntities "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	managementRepository "github.com/ZupIT/horusec-platform/vulnerability/internal/repositories/management"
)

func TestNewManagementController(t *testing.T) {
	t.Run("should success create a new controller", func(t *testing.T) {
		assert.NotNil(t, NewManagementController(nil, nil))
	})
}

func TestGetAllVulnerabilities(t *testing.T) {
	t.Run("should success get all vulnerabilities", func(t *testing.T) {
		brokerMock := &broker.Mock{}

		repositoryMock := &managementRepository.Mock{}
		repositoryMock.On("GetAllVulnerabilities").Return(&managementEntities.Response{}, nil)

		controller := NewManagementController(repositoryMock, brokerMock)

		result, err := controller.GetAllVulnerabilities(&managementEntities.Filter{})
		assert.NoError(t, err)
		assert.NotNil(t, result)
	})
}

func TestUpdateVulnerability(t *testing.T) {
	t.Run("should success update vulnerabilities", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		brokerMock.On("Publish").Return(nil)

		repositoryMock := &managementRepository.Mock{}
		repositoryMock.On("GetVulnerability").Return(&vulnerabilityEntities.Vulnerability{}, nil)
		repositoryMock.On("UpdateVulnerability").Return(nil)
		repositoryMock.On("GetAnalysis").Return(&analysisEntities.Analysis{}, nil)

		controller := NewManagementController(repositoryMock, brokerMock)

		assert.NoError(t, controller.UpdateVulnerabilities(&managementEntities.Data{}))
	})

	t.Run("should return error when getting analysis", func(t *testing.T) {
		brokerMock := &broker.Mock{}

		repositoryMock := &managementRepository.Mock{}
		repositoryMock.On("GetVulnerability").Return(&vulnerabilityEntities.Vulnerability{}, nil)
		repositoryMock.On("UpdateVulnerability").Return(nil)
		repositoryMock.On("GetAnalysis").Return(&analysisEntities.Analysis{}, errors.New("test"))

		controller := NewManagementController(repositoryMock, brokerMock)

		assert.Error(t, controller.UpdateVulnerabilities(&managementEntities.Data{}))
	})

	t.Run("should return error when updating vulnerabilities", func(t *testing.T) {
		brokerMock := &broker.Mock{}

		repositoryMock := &managementRepository.Mock{}
		repositoryMock.On("GetVulnerability").Return(&vulnerabilityEntities.Vulnerability{}, nil)
		repositoryMock.On("UpdateVulnerability").Return(errors.New("test"))

		controller := NewManagementController(repositoryMock, brokerMock)

		assert.Error(t, controller.UpdateVulnerabilities(&managementEntities.Data{}))
	})

	t.Run("should return error when getting vulnerability", func(t *testing.T) {
		brokerMock := &broker.Mock{}

		repositoryMock := &managementRepository.Mock{}
		repositoryMock.On("GetVulnerability").Return(
			&vulnerabilityEntities.Vulnerability{}, errors.New("test"))

		controller := NewManagementController(repositoryMock, brokerMock)

		assert.Error(t, controller.UpdateVulnerabilities(&managementEntities.Data{}))
	})
}
