// Copyright 2021 ZUP IT SERVICOS EM TECNOLOGIA E INOVACAO SA
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package management

import (
	"time"

	"github.com/go-enry/go-enry/v2"

	"github.com/google/uuid"
	"github.com/pkg/errors"

	"github.com/ZupIT/horusec-devkit/pkg/enums/exchange"
	brokerLib "github.com/ZupIT/horusec-devkit/pkg/services/broker"
	"github.com/ZupIT/horusec-devkit/pkg/services/database"
	"github.com/ZupIT/horusec-devkit/pkg/utils/logger"

	managementEntities "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	managementEnums "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"
	managementRepository "github.com/ZupIT/horusec-platform/vulnerability/internal/repositories/management"
	managementUseCases "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/management"
)

type IController interface {
	ListVulnerabilitiesByFile(filter *managementEntities.Filter) (*managementEntities.ResponseVulnerabilitiesByFile, error)
	ListVulnerableFiles(filter *managementEntities.Filter) (*managementEntities.ResponseFilesVulnerable, error)
	UpdateVulnerabilities(data *managementEntities.UpdateData) error
}

type Controller struct {
	repository    managementRepository.IRepository
	broker        brokerLib.IBroker
	databaseWrite database.IDatabaseWrite
	useCases      managementUseCases.IUseCases
}

func NewManagementController(repository managementRepository.IRepository, broker brokerLib.IBroker,
	databaseConnection *database.Connection, useCases managementUseCases.IUseCases) IController {
	return &Controller{
		repository:    repository,
		broker:        broker,
		databaseWrite: databaseConnection.Write,
		useCases:      useCases,
	}
}

func (c *Controller) ListVulnerabilitiesByFile(
	filter *managementEntities.Filter) (*managementEntities.ResponseVulnerabilitiesByFile, error) {
	return c.repository.ListVulnerabilitiesByFile(filter)
}

func (c *Controller) ListVulnerableFiles(
	filter *managementEntities.Filter) (*managementEntities.ResponseFilesVulnerable, error) {
	response, err := c.repository.ListVulnerableFiles(filter)
	if err != nil {
		return nil, err
	}
	for k, v := range response.Data {
		response.Data[k].Languages = enry.GetLanguages(v.File, nil)
	}
	return response, nil
}

func (c *Controller) UpdateVulnerabilities(data *managementEntities.UpdateData) error {
	transaction := c.databaseWrite.StartTransaction()

	for _, vulnerability := range data.Vulnerabilities {
		if err := c.updateVulnerability(vulnerability, transaction); err != nil {
			logger.LogError(managementEnums.MessageFailedToRollbackUpdate, transaction.RollbackTransaction().GetError())
			return err
		}
	}

	if err := transaction.CommitTransaction().GetError(); err != nil {
		return errors.Wrap(err, managementEnums.MessageFailedToCommitUpdateTransaction)
	}

	return c.publishAnalysisChanges(data.AnalysisID)
}

func (c *Controller) updateVulnerability(
	data *managementEntities.VulnerabilityData, transaction database.IDatabaseWrite) error {
	vulnerability, err := c.repository.GetVulnerability(data.VulnerabilityID)
	if err != nil {
		return err
	}

	vulnerability.SetType(data.Type)
	vulnerability.SetSeverity(data.Severity)
	return transaction.Update(vulnerability, c.useCases.FilterVulnerabilityByID(vulnerability.VulnerabilityID),
		managementEnums.VulnerabilitiesTable).GetError()
}

func (c *Controller) publishAnalysisChanges(analysisID uuid.UUID) error {
	analysis, err := c.repository.GetAnalysis(analysisID)
	if err != nil {
		return err
	}

	analysis.CreatedAt = time.Now() // send an updated analysis to analytic.
	return c.broker.Publish("", exchange.NewAnalysis, exchange.Fanout, analysis.ToBytes())
}
