package vulnerability

import (
	"errors"
	"testing"

	"github.com/ZupIT/horusec-devkit/pkg/services/broker"

	entityVulnerability "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/stretchr/testify/assert"

	entity "github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
	"github.com/ZupIT/horusec-platform/vulnerability/internal/repositories/vulnerability"
)

func TestController_FindAllVulnerabilityByFilter(t *testing.T) {
	t.Run("Should return all vulnerabilities without error", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		repoMock := &vulnerability.Mock{}
		repoMock.On("FindAllVulnerabilitiesByFilter").Return(&entity.FindVulnerabilities{
			TotalItems: 1,
			Data:       []entityVulnerability.Vulnerability{{}},
		}, nil)
		result, err := NewVulnerabilitiesController(repoMock, brokerMock).FindAllVulnerabilityByFilter(&entity.FilterToFindAllVulnerabilities{})
		assert.NoError(t, err)
		assert.NotEmpty(t, result)
	})
	t.Run("Should return all vulnerabilities with error", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		repoMock := &vulnerability.Mock{}
		repoMock.On("FindAllVulnerabilitiesByFilter").Return(&entity.FindVulnerabilities{}, errors.New("unexpected error"))
		result, err := NewVulnerabilitiesController(repoMock, brokerMock).FindAllVulnerabilityByFilter(&entity.FilterToFindAllVulnerabilities{})
		assert.Equal(t, errors.New("unexpected error"), err)
		assert.Empty(t, result)
	})
}

func TestController_UpdateVulnerability(t *testing.T) {
	t.Run("Should update vulnerability without error", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		brokerMock.On("Publish").Return(nil)
		repoMock := &vulnerability.Mock{}
		repoMock.On("UpdateVulnerability").Return(nil)
		repoMock.On("GetVulnerabilityBYID").Return(&entityVulnerability.Vulnerability{}, nil)
		err := NewVulnerabilitiesController(repoMock, brokerMock).UpdateVulnerability(&entity.UpdateVulnerability{})
		assert.NoError(t, err)
	})
	t.Run("Should update vulnerability with error on update vulnerability", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		repoMock := &vulnerability.Mock{}
		repoMock.On("GetVulnerabilityBYID").Return(&entityVulnerability.Vulnerability{}, nil)
		repoMock.On("UpdateVulnerability").Return(errors.New("unexpected error"))
		err := NewVulnerabilitiesController(repoMock, brokerMock).UpdateVulnerability(&entity.UpdateVulnerability{})
		assert.Error(t, err)
	})
	t.Run("Should update vulnerability with error on get existing vulnerability and return nil entity", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		repoMock := &vulnerability.Mock{}
		repoMock.On("UpdateVulnerability").Return(nil)
		repoMock.On("GetVulnerabilityBYID").Return(nil, nil)
		err := NewVulnerabilitiesController(repoMock, brokerMock).UpdateVulnerability(&entity.UpdateVulnerability{})
		assert.Error(t, err)
	})
	t.Run("Should update vulnerability with error on get existing vulnerability", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		repoMock := &vulnerability.Mock{}
		repoMock.On("UpdateVulnerability").Return(nil)
		repoMock.On("GetVulnerabilityBYID").Return(&entityVulnerability.Vulnerability{}, errors.New("unexpected error"))
		err := NewVulnerabilitiesController(repoMock, brokerMock).UpdateVulnerability(&entity.UpdateVulnerability{})
		assert.Error(t, err)
	})
	t.Run("Should update vulnerability with error on publish in broker", func(t *testing.T) {
		brokerMock := &broker.Mock{}
		brokerMock.On("Publish").Return(errors.New("unexpected error"))
		repoMock := &vulnerability.Mock{}
		repoMock.On("UpdateVulnerability").Return(nil)
		repoMock.On("GetVulnerabilityBYID").Return(&entityVulnerability.Vulnerability{}, nil)
		err := NewVulnerabilitiesController(repoMock, brokerMock).UpdateVulnerability(&entity.UpdateVulnerability{})
		assert.Error(t, err)
	})
}
