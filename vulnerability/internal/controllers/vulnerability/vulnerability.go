package vulnerability

import (
	"time"

	"github.com/ZupIT/horusec-devkit/pkg/enums/exchange"
	"github.com/ZupIT/horusec-devkit/pkg/services/broker"
	"github.com/google/uuid"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
	repositoriesVulnerability "github.com/ZupIT/horusec-platform/vulnerability/internal/repositories/vulnerability"
)

type IController interface {
	FindAllVulnerabilityByFilter(
		filter *vulnerability.FilterToFindAllVulnerabilities) (*vulnerability.FindVulnerabilities, error)
	UpdateVulnerability(entity *vulnerability.UpdateVulnerability) error
}

type Controller struct {
	repoVulnerability repositoriesVulnerability.IRepositoryVulnerability
	broker            broker.IBroker
}

func NewVulnerabilitiesController(repoVulnerability repositoriesVulnerability.IRepositoryVulnerability,
	iBroker broker.IBroker) IController {
	return &Controller{
		repoVulnerability: repoVulnerability,
		broker:            iBroker,
	}
}

func (c *Controller) FindAllVulnerabilityByFilter(
	filter *vulnerability.FilterToFindAllVulnerabilities) (*vulnerability.FindVulnerabilities, error) {
	return c.repoVulnerability.FindAllVulnerabilitiesByFilter(filter)
}

func (c *Controller) UpdateVulnerability(entityToUpdate *vulnerability.UpdateVulnerability) error {
	if err := c.repoVulnerability.UpdateVulnerability(entityToUpdate); err != nil {
		return err
	}
	return c.publishInBroker(entityToUpdate.VulnerabilityID)
}

func (c *Controller) publishInBroker(vulnerabilityID uuid.UUID) error {
	allAnalysis, err := c.repoVulnerability.GetAllAnalysisByVulnerabilityID(vulnerabilityID)
	if err != nil {
		return err
	}
	for key := range allAnalysis {
		entity := &allAnalysis[key]
		entity.CreatedAt = time.Now()
		if err := c.broker.Publish("", exchange.NewAnalysis,
			exchange.Fanout, entity.ToBytes()); err != nil {
			return err
		}
	}
	return nil
}
