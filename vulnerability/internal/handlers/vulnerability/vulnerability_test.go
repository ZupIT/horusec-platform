package vulnerability

import (
	"context"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/ZupIT/horusec-devkit/pkg/utils/parser"

	useCaseVulnerability "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/vulnerability"

	filtervulnerabilities "github.com/ZupIT/horusec-platform/vulnerability/internal/enums"
	useCaseVulnerabilityFilter "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/vulnerability_filter"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	controller "github.com/ZupIT/horusec-platform/vulnerability/internal/controllers/vulnerability"
	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"

	entityVulnerability "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/enums/confidence"
	"github.com/ZupIT/horusec-devkit/pkg/enums/languages"
	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database/enums"
)

func TestHandler_Options(t *testing.T) {
	t.Run("Should return no content when call options", func(t *testing.T) {
		handler := NewVulnerabilitiesHandler(nil)
		r, _ := http.NewRequest(http.MethodOptions, "/test", nil)
		w := httptest.NewRecorder()

		handler.Options(w, r)

		assert.Equal(t, http.StatusNoContent, w.Code)
	})
}

func TestHandler_Get(t *testing.T) {
	t.Run("Should return status OK when find all vulnerabilities found by filter", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{
				TotalItems: 1,
				Data: []entityVulnerability.Vulnerability{
					{
						VulnerabilityID: uuid.New(),
						Line:            "1",
						Column:          "1",
						Confidence:      confidence.High,
						File:            "/deployments/cert.pem",
						Code:            "-----BEGIN CERTIFICATE-----",
						Details:         "Asymmetric Private Key \n Found SSH and/or x.509 Cerficates among the files of your project, make sure you want this kind of information inside your Git repo, since it can be missused by someone with access to any kind of copy.  For more information checkout the CWE-312 (https://cwe.mitre.org/data/definitions/312.html) advisory.",
						SecurityTool:    "Wrong security tool",
						Language:        languages.Leaks,
						Severity:        severities.Critical,
						VulnHash:        "1234567890",
						Type:            enumsVulnerability.Vulnerability,
						CommitAuthor:    "Wilian Gabriel",
						CommitEmail:     "wilian.silva@zup.com.br",
						CommitHash:      "9876543210",
						CommitMessage:   "Initial Commit",
						CommitDate:      "2021-03-31T10:58:42Z",
					},
				},
			}, nil)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&vulnerability.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical,
			VulnType:     enumsVulnerability.Vulnerability,
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status OK when not found vulnerabilities by filter", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&vulnerability.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical,
			VulnType:     enumsVulnerability.Vulnerability,
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status bad request when not found repositoryID on path", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&vulnerability.FilterToFindAllVulnerabilities{}, filtervulnerabilities.ErrorWrongRepositoryID)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", "aleatory")
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
	t.Run("Should return status internal server error when unexpected error on find vulnerabilities", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, errors.New("unexpected error"))
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&vulnerability.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical,
			VulnType:     enumsVulnerability.Vulnerability,
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusInternalServerError, w.Code)
	})
}

func TestHandler_Patch(t *testing.T) {
	t.Run("Should return no content when update vulnerability", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &vulnerability.UpdateVulnerability{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}
		controllerMock := &controller.Mock{}
		controllerMock.On("UpdateVulnerability").Return(nil)
		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(entityToUpdate, nil)
		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}
		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)
		w := httptest.NewRecorder()
		r, _ := http.NewRequest(http.MethodPatch, "/test", body)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
		handler.Patch(w, r)
		assert.Equal(t, http.StatusNoContent, w.Code)
	})
	t.Run("Should return unexpected error on update vulnerability", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &vulnerability.UpdateVulnerability{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}
		controllerMock := &controller.Mock{}
		controllerMock.On("UpdateVulnerability").Return(errors.New("unexpected error"))
		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(entityToUpdate, nil)
		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}
		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)
		w := httptest.NewRecorder()
		r, _ := http.NewRequest(http.MethodPatch, "/test", body)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
		handler.Patch(w, r)
		assert.Equal(t, http.StatusInternalServerError, w.Code)
	})
	t.Run("Should return bad request when not exists vulnerabilityID on URL", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &vulnerability.UpdateVulnerability{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}
		controllerMock := &controller.Mock{}
		controllerMock.On("UpdateVulnerability").Return(nil)
		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(&vulnerability.UpdateVulnerability{}, filtervulnerabilities.ErrorWrongVulnerabilityID)
		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}
		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)
		w := httptest.NewRecorder()
		r, _ := http.NewRequest(http.MethodPatch, "/test", body)
		ctx := chi.NewRouteContext()
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
		handler.Patch(w, r)
		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
	t.Run("Should return bad request when not exists severity on body", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &vulnerability.UpdateVulnerability{
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}
		controllerMock := &controller.Mock{}
		controllerMock.On("UpdateVulnerability").Return(nil)
		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(&vulnerability.UpdateVulnerability{}, errors.New("severity: unexpected type"))
		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}
		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)
		w := httptest.NewRecorder()
		r, _ := http.NewRequest(http.MethodPatch, "/test", body)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
		handler.Patch(w, r)
		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
	t.Run("Should return bad request when not exists type on body", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &vulnerability.UpdateVulnerability{
			Severity:        severities.Critical,
			VulnerabilityID: vulnerabilityID,
		}
		controllerMock := &controller.Mock{}
		controllerMock.On("UpdateVulnerability").Return(nil)
		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(&vulnerability.UpdateVulnerability{}, errors.New("type: unexpected type"))
		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}
		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)
		w := httptest.NewRecorder()
		r, _ := http.NewRequest(http.MethodPatch, "/test", body)
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))
		handler.Patch(w, r)
		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
}
