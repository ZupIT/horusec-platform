package vulnerability

import (
	"context"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/ZupIT/horusec-platform/vulnerability/internal/controllers/vulnerabilities"
	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/vulnerability"
	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	entityVulnerability "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/enums/confidence"
	"github.com/ZupIT/horusec-devkit/pkg/enums/languages"
	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database/enums"
)

func TestHandler_Options(t *testing.T) {
	t.Run("Should return no content when call options", func(t *testing.T) {
		handler := NewVulnerabilitiesHandler(nil)
		r, _ := http.NewRequest(http.MethodOptions, "/test", nil)
		w := httptest.NewRecorder()

		handler.Options(w, r)

		assert.Equal(t, http.StatusNoContent, w.Code)
	})
}

func TestHandler_Get(t *testing.T) {
	t.Run("Should return status OK when find all vulnerabilities found by filter", func(t *testing.T) {
		controllerMock := &vulnerabilities.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{
				TotalItems: 1,
				Data: []entityVulnerability.Vulnerability{
					{
						VulnerabilityID: uuid.New(),
						Line:            "1",
						Column:          "1",
						Confidence:      confidence.High.ToString(),
						File:            "/deployments/cert.pem",
						Code:            "-----BEGIN CERTIFICATE-----",
						Details:         "Asymmetric Private Key \n Found SSH and/or x.509 Cerficates among the files of your project, make sure you want this kind of information inside your Git repo, since it can be missused by someone with access to any kind of copy.  For more information checkout the CWE-312 (https://cwe.mitre.org/data/definitions/312.html) advisory.",
						SecurityTool:    "Wrong security tool",
						Language:        languages.Leaks,
						Severity:        severities.Critical,
						VulnHash:        "1234567890",
						Type:            enumsVulnerability.Vulnerability,
						CommitAuthor:    "Wilian Gabriel",
						CommitEmail:     "wilian.silva@zup.com.br",
						CommitHash:      "9876543210",
						CommitMessage:   "Initial Commit",
						CommitDate:      "2021-03-31T10:58:42Z",
					},
				},
			}, nil)
		handler := NewVulnerabilitiesHandler(controllerMock)
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status OK when not found vulnerabilities by filter", func(t *testing.T) {
		controllerMock := &vulnerabilities.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		handler := NewVulnerabilitiesHandler(controllerMock)
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status bad request when not found repositoryID on path", func(t *testing.T) {
		controllerMock := &vulnerabilities.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		handler := NewVulnerabilitiesHandler(controllerMock)
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", "aleatory")
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
	t.Run("Should return status internal server error when unexpected error on find vulnerabilities", func(t *testing.T) {
		controllerMock := &vulnerabilities.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&vulnerability.FindVulnerabilities{}, errors.New("unexpected error"))
		handler := NewVulnerabilitiesHandler(controllerMock)
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Get(w, r)

		assert.Equal(t, http.StatusInternalServerError, w.Code)
	})
}
