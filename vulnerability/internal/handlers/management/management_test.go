package management

import (
	"context"
	"errors"
	"net/http"
	"net/http/httptest"
	"testing"

	vulnerability2 "github.com/ZupIT/horusec-platform/vulnerability/internal/enums/management"

	"github.com/go-chi/chi"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"

	entityVulnerability "github.com/ZupIT/horusec-devkit/pkg/entities/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/enums/confidence"
	"github.com/ZupIT/horusec-devkit/pkg/enums/languages"
	"github.com/ZupIT/horusec-devkit/pkg/enums/severities"
	enumsVulnerability "github.com/ZupIT/horusec-devkit/pkg/enums/vulnerability"
	"github.com/ZupIT/horusec-devkit/pkg/services/database/enums"
	"github.com/ZupIT/horusec-devkit/pkg/utils/parser"

	controller "github.com/ZupIT/horusec-platform/vulnerability/internal/controllers/management"
	"github.com/ZupIT/horusec-platform/vulnerability/internal/entities/management"
	useCaseVulnerability "github.com/ZupIT/horusec-platform/vulnerability/internal/usecase/management"
)

func TestHandler_Options(t *testing.T) {
	t.Run("should return no content when call options", func(t *testing.T) {
		handler := NewManagementHandler(nil, nil)
		r, _ := http.NewRequest(http.MethodOptions, "/test", nil)
		w := httptest.NewRecorder()

		handler.Options(w, r)

		assert.Equal(t, http.StatusNoContent, w.Code)
	})
}

func TestHandler_Get(t *testing.T) {
	t.Run("Should return status OK when find all vulnerabilities by workspace found by filter", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&management.Response{
				TotalItems: 1,
				Data: []entityVulnerability.Vulnerability{
					{
						VulnerabilityID: uuid.New(),
						Line:            "1",
						Column:          "1",
						Confidence:      confidence.High,
						File:            "/deployments/cert.pem",
						Code:            "-----BEGIN CERTIFICATE-----",
						Details:         "Asymmetric Private Key ...",
						SecurityTool:    "Wrong security tool",
						Language:        languages.Leaks,
						Severity:        severities.Critical,
						VulnHash:        "1234567890",
						Type:            enumsVulnerability.Vulnerability,
						CommitAuthor:    "Wilian Gabriel",
						CommitEmail:     "wilian.silva@zup.com.br",
						CommitHash:      "9876543210",
						CommitMessage:   "Initial Commit",
						CommitDate:      "2021-03-31T10:58:42Z",
					},
				},
			}, nil)

		handler := &Handler{
			controller: controllerMock,
			useCases:   test,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("workspaceID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.GetByWorkspace(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status OK when find all vulnerabilities found by filter", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&management.FindVulnerabilities{
				TotalItems: 1,
				Data: []entityVulnerability.Vulnerability{
					{
						VulnerabilityID: uuid.New(),
						Line:            "1",
						Column:          "1",
						Confidence:      confidence.High,
						File:            "/deployments/cert.pem",
						Code:            "-----BEGIN CERTIFICATE-----",
						Details:         "Asymmetric Private Key \n Found SSH and/or x.509 Cerficates among the files of your project, make sure you want this kind of information inside your Git repo, since it can be missused by someone with access to any kind of copy.  For more information checkout the CWE-312 (https://cwe.mitre.org/data/definitions/312.html) advisory.",
						SecurityTool:    "Wrong security tool",
						Language:        languages.Leaks,
						Severity:        severities.Critical,
						VulnHash:        "1234567890",
						Type:            enumsVulnerability.Vulnerability,
						CommitAuthor:    "Wilian Gabriel",
						CommitEmail:     "wilian.silva@zup.com.br",
						CommitHash:      "9876543210",
						CommitMessage:   "Initial Commit",
						CommitDate:      "2021-03-31T10:58:42Z",
					},
				},
			}, nil)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&management.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     enumsVulnerability.Vulnerability.ToString(),
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.GetByRepository(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status OK when not found vulnerabilities by filter", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&management.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&management.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     enumsVulnerability.Vulnerability.ToString(),
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.GetByRepository(w, r)

		assert.Equal(t, http.StatusOK, w.Code)
	})
	t.Run("Should return status bad request when not found repositoryID on path", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&management.FindVulnerabilities{}, enums.ErrorNotFoundRecords)
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(
			&management.FilterToFindAllVulnerabilities{}, vulnerability2.ErrorWrongRepositoryID)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", "aleatory")
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.GetByRepository(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})
	t.Run("Should return status internal server error when unexpected error on find vulnerabilities", func(t *testing.T) {
		controllerMock := &controller.Mock{}
		controllerMock.On("FindAllVulnerabilityByFilter").Return(
			&management.FindVulnerabilities{}, errors.New("unexpected error"))
		useCaseVulnerabilityFilterMock := &useCaseVulnerabilityFilter.Mock{}
		useCaseVulnerabilityFilterMock.On("ParseQueryInFilterToFindAllVulnerabilities").Return(&management.FilterToFindAllVulnerabilities{
			RepositoryID: uuid.New(),
			Page:         0,
			Size:         10,
			VulnSeverity: severities.Critical.ToString(),
			VulnType:     enumsVulnerability.Vulnerability.ToString(),
			VulnHash:     "123456",
		}, nil)
		handler := &Handler{
			controller:                 controllerMock,
			useCaseVulnerabilityFilter: useCaseVulnerabilityFilterMock,
		}
		r, _ := http.NewRequest(http.MethodGet, "/test", nil)
		w := httptest.NewRecorder()
		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("repositoryID", uuid.NewString())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.GetByRepository(w, r)

		assert.Equal(t, http.StatusInternalServerError, w.Code)
	})
}

func TestHandler_Patch(t *testing.T) {
	t.Run("should return no content when update vulnerability", func(t *testing.T) {
		vulnerabilityID := uuid.New()
		entityToUpdate := &management.Data{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(nil)

		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(entityToUpdate, nil)

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusNoContent, w.Code)
	})

	t.Run("should return unexpected error on update vulnerability", func(t *testing.T) {
		vulnerabilityID := uuid.New()

		entityToUpdate := &management.Data{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(errors.New("unexpected error"))

		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(entityToUpdate, nil)

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusInternalServerError, w.Code)
	})

	t.Run("should return bad request when not exists vulnerabilityID on URL", func(t *testing.T) {
		vulnerabilityID := uuid.New()

		entityToUpdate := &management.Data{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(nil)

		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(
			&management.Data{}, vulnerability2.ErrorWrongVulnerabilityID)

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})

	t.Run("should return bad request when not exists severity on body", func(t *testing.T) {
		vulnerabilityID := uuid.New()

		entityToUpdate := &management.Data{
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(nil)

		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(
			&management.Data{}, errors.New("severity: unexpected type"))

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})

	t.Run("should return bad request when not exists type on body", func(t *testing.T) {
		vulnerabilityID := uuid.New()

		entityToUpdate := &management.Data{
			Severity:        severities.Critical,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(nil)

		useCaseVulnerabilityMock := &useCaseVulnerability.Mock{}
		useCaseVulnerabilityMock.On("DecodeUpdateVulnerabilityFromIoRead").Return(
			&management.Data{}, errors.New("type: unexpected type"))

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerabilityMock,
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusBadRequest, w.Code)
	})

	t.Run("should return 404 when not found vulnerability", func(t *testing.T) {
		vulnerabilityID := uuid.New()

		entityToUpdate := &management.Data{
			Severity:        severities.Critical,
			Type:            enumsVulnerability.Vulnerability,
			VulnerabilityID: vulnerabilityID,
		}

		controllerMock := &controller.Mock{}
		controllerMock.On("Data").Return(enums.ErrorNotFoundRecords)

		handler := &Handler{
			controller:           controllerMock,
			useCaseVulnerability: useCaseVulnerability.NewUseCaseVulnerability(),
		}

		body, err := parser.ParseEntityToIOReadCloser(entityToUpdate)
		assert.NoError(t, err)

		w := httptest.NewRecorder()

		r, _ := http.NewRequest(http.MethodPatch, "/test", body)

		ctx := chi.NewRouteContext()
		ctx.URLParams.Add("vulnerabilityID", vulnerabilityID.String())
		r = r.WithContext(context.WithValue(r.Context(), chi.RouteCtxKey, ctx))

		handler.Patch(w, r)

		assert.Equal(t, http.StatusNotFound, w.Code)
	})
}
